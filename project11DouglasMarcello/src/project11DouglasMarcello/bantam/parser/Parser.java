/*
 * Date: Spring and Summer, 2018
 * Authors: Haoyu Song, Dale Skrien, Liwei Jiang, Tracy Quan, Danqing Zhao, Chris Marcello
 *
 * In the grammar below, the variables are enclosed in angle brackets.
 * The notation "::=" is used instead of "-->" to separate a variable from its rules.
 * The special character "|" is used to separate the rules for each variable.
 * All other symbols in the rules are terminals.
 * EMPTY indicates a rule with an empty right hand side.
 * All other terminal symbols that are in all caps correspond to keywords.
 */
package project11DouglasMarcello.bantam.parser;

import java.util.List;
import project11DouglasMarcello.bantam.util.*;
import project11DouglasMarcello.bantam.util.Error;
import project11DouglasMarcello.bantam.lexer.*;
import project11DouglasMarcello.bantam.ast.*;
import project11DouglasMarcello.bantam.treedrawer.Drawer;
import static project11DouglasMarcello.bantam.lexer.Token.Kind.*;

/**
 * This class constructs an AST from a legal Bantam Java program.
 * If the program is illegal, then one or more error messages are displayed.
 *
 * @author Liwei Jiang
 * @author Tracy Quan
 * @author Danqing Zhao
 * @author Chris Marcello
 */
public class Parser {
    /**
     * the scanner object that generates tokens of a specified file
     */
    private Scanner scanner;
    /**
     * the name of file to be parsed
     */
    private String fileName;
    /**
     * the lookahead token
     */
    private Token currentToken;
    /**
     * an error handler storing the Errors in a list
     */
    private ErrorHandler errorHandler;

    /**
     * The constructor of the Parser class.
     *
     * @param errorHandler the ErrorHandler object that stores a list of errors
     */
    public Parser(ErrorHandler errorHandler) { this.errorHandler = errorHandler; }

    /**
     * Parses the given file and returns the root node of the AST.
     *
     * @param filename The name of the Bantam Java file to be parsed
     * @return The Program node forming the root of the AST generated by the parser
     */
    public Program parse(String filename) {
        this.fileName = filename;
        this.scanner = new Scanner(filename, this.errorHandler);
        this.scan();
        return parseProgram();
    }

    /**
     * Gets the next Token from the scanner and assigns it to the currentToken field.
     * Skips the COMMENT Tokens.
     * Throws a compilation error when encountering illegal Tokens.
     */
    private void scan() {
        this.currentToken = this.scanner.scan();
        // skip the comments
        while (this.currentToken.kind == COMMENT) {
            this.currentToken = this.scanner.scan();
        }
        // throw a CompilationException if the current Token is an illegal Token
        if (this.currentToken.kind == ERROR) {
            throw new CompilationException("Illegal token " + this.currentToken.spelling + " was found.");
        }
    }

    /**
     * Helper method to register an error to the error handler.
     *
     * @param message the error message
     */
    private void registerError(String message) {
        this.errorHandler.register(Error.Kind.PARSE_ERROR, this.fileName, this.currentToken.position, message);
        throw new CompilationException(message);
    }

    /**
     * Helper method to check whether the current token matches to the target string.
     * If the current Token does not match, then registers an error indicating the mismatch.
     *
     * @param targetStr a String that we want to check whether it matches to the current token
     * @param errorMsg s String of error message to notify a mismatch happens
     */
    private void checkCurrentTokenMatched(String targetStr, String errorMsg) {
        if (!this.currentToken.spelling.equals(targetStr)) {
            this.registerError(errorMsg);
        }
    }

    /*
     * <Program> ::= <Class> | <Class> <Program>
     */
    private Program parseProgram() {
        int position = currentToken.position;
        ClassList classList = new ClassList(position);

        while (currentToken.kind != EOF) {
            Class_ aClass = this.parseClass();
            classList.addElement(aClass);
        }
        return new Program(position, classList);
    }

    /*
     * <ExtendsClause> ::= EXTENDS <Identifier> | EMPTY
     */
    private String parseExtendsClause() {
        String parentName;
        // <ExtendsClause>
        if (this.currentToken.kind == EXTENDS) {
            this.scan();
            // <Identifier>
            parentName = this.parseIdentifier("Illegal extended class name.");
        }
        // EMPTY
        else {
            parentName = null;
        }
        return parentName;
    }

    /*
     * <MemberList> ::= EMPTY | <Member> <MemberList>
     */
    private MemberList parseMemberList() {
        MemberList memberList = new MemberList(this.currentToken.position);
        if (!this.currentToken.spelling.equals("}")) {
            while (!this.currentToken.spelling.equals("}")){
                Member aMember = this.parseMember();
                memberList.addElement(aMember);
                // if missing the right curly brace "}"
                if (this.currentToken.getKind().equals(EOF)) {
                    this.registerError("Class definition missing the right curly brace }.");
                    break;
                }
            }
        }
        return memberList;
    }

    /*
     * <Class> ::= CLASS <Identifier> <ExtendsClause> { <MemberList> }
     */
    private Class_ parseClass() {
        int position = this.currentToken.position;

        // CLASS
        // if the class keyword is illegal
        this.checkCurrentTokenMatched("class", "The class definition is illegal.");

        // <Identifier>
        this.scan();
        String name = this.parseIdentifier("Illegal class name.");

        // <ExtendsClause>
        String parentName = this.parseExtendsClause();

        // "{"
        this.checkCurrentTokenMatched("{", "Class definition missing the left curly brace {.");

        // <MemberList>
        this.scan();
       MemberList memberList = this.parseMemberList();

        // "}"
        this.checkCurrentTokenMatched("}", "Class definition missing the right curly brace }.");

        this.scan();
        return new Class_(position, this.fileName, name, parentName, memberList);
    }

    /*
     * <Method> ::= <Type> <Identifier> ( <Parameters> ) <Block>
     */
    private Method parseMethod(int position, String type, String identifier) {
        this.scan();
        // <Parameters>
        FormalList parameter = this.parseParameters();

        // ")"
        this.checkCurrentTokenMatched(")", "Method declaration missing the right parenthesis ).");

        // <Block>
        this.scan();
        Stmt stmt = this.parseBlock();
        StmtList stmtList = new StmtList(this.currentToken.position);
        stmtList.addElement(stmt);
        return new Method(position, type, identifier, parameter, stmtList);
    }

    /*
     * <Field> ::= <Type> <Identifier> <InitialValue> ;
     * <InitialValue> ::= EMPTY | = <Expression>;
     */
    private Field parseField(String type, String identifier) {
        // if the field is initialized
        // "="
        if (this.currentToken.spelling.equals("=")){
            // <InitialValue>
            this.scan();
            Expr init = this.parseExpression();

            // ";"
            this.checkCurrentTokenMatched(";", "Field declaration missing a semicolon ;.");

            int position = this.currentToken.position;
            this.scan();
            return new Field(position, type, identifier, init);
        }
        // if the field is declared but not initialized
        // EMPTY
        else if (this.currentToken.spelling.equals(";")){
            int position = this.currentToken.position;
            this.scan();
            return new Field(position, type, identifier, null);
        }
        // if not a field
        else{
            this.registerError("Illegal field declaration.");
            this.scan();
            return null;
        }
    }

    /* Fields and Methods
     * <Member> ::= <Field> | <Method>
     * <Field> ::= <Type> <Identifier> <InitialValue> ;
     * <Method> ::= <Type> <Identifier> ( <Parameters> ) <Block>
     * <InitialValue> ::= EMPTY | = <Expression>;
     */
    private Member parseMember() {
        int position = this.currentToken.position;
        // <Type>
        String type = this.parseType();
        // <Identifier>
        String identifier = this.parseIdentifier("Illegal member name.");

        // if <Method>
        if (this.currentToken.spelling.equals("(")){
            return this.parseMethod(position, type, identifier);
        }
        // if <Field>
        else{
            return this.parseField(type, identifier);
        }
    }

    // ----------------------------------- Statements -----------------------------------

    /*
     *  <Stmt> ::= <WhileStmt> | <ReturnStmt> | <BreakStmt> | <DeclStmt>
     *              | <ExpressionStmt> | <ForStmt> | <BlockStmt> | <IfStmt>
     */
    private Stmt parseStatement() {
        Stmt stmt;

        switch (this.currentToken.kind) {
            case IF:
                stmt = this.parseIf();
                break;
            case LCURLY:
                stmt = this.parseBlock();
                break;
            case VAR:
                stmt = this.parseDeclStmt();
                break;
            case RETURN:
                stmt = this.parseReturn();
                break;
            case FOR:
                stmt = this.parseFor();
                break;
            case WHILE:
                stmt = this.parseWhile();
                break;
            case BREAK:
                stmt = this.parseBreak();
                break;
            default:
                stmt = this.parseExpressionStmt();
        }
        return stmt;
    }


    /*
     * <WhileStmt> ::= WHILE ( <Expression> ) <Stmt>
     */
    private Stmt parseWhile() {
        int position = this.currentToken.position;

        // (
        this.scan();
        this.checkCurrentTokenMatched("(", "While statement missing a left parenthesis (.");

        // <Expression>
        this.scan();
        Expr preExpr = this.parseExpression();

        // )
        this.checkCurrentTokenMatched(")", "While statement missing a right parenthesis ).");

        // <Stmt>
        this.scan();
        Stmt stmt = this.parseStatement();

        return new WhileStmt(position, preExpr, stmt);
    }


    /*
     * <ReturnStmt> ::= RETURN <Expression> ; | RETURN ;
     */
    private Stmt parseReturn() {
        int position = this.currentToken.position;
        Stmt stmt;
        this.scan();

        // RETURN ;
        if (this.currentToken.spelling.equals(";")) {
            stmt = new ReturnStmt(position, null);
        }
        // RETURN <Expression> ;
        else {
            // <Expression>
            Expr returnExpr = this.parseExpression();

            // ;
            this.checkCurrentTokenMatched(";", "Return statement missing a semicolon ;.");
            stmt = new ReturnStmt(position, returnExpr);
        }
        this.scan();
        return stmt;
    }


    /*
     * BreakStmt> ::= BREAK ;
     */
    private Stmt parseBreak() {
        Token tmpToken = this.currentToken;
        this.scan();
        this.checkCurrentTokenMatched(";", "Break statement missing a semicolon ;.");
        this.scan();
        return new BreakStmt(tmpToken.position);
    }


    /*
     * <ExpressionStmt> ::= <Expression> ;
     */
    private ExprStmt parseExpressionStmt() {
        int position = this.currentToken.position;

        // <Expression>
        Expr expr = this.parseExpression();

        // ";"
        this.checkCurrentTokenMatched(";", "Expression statement missing a semicolon ;.");
        this.scan();

        return new ExprStmt(position, expr);
    }


    /*
     * <DeclStmt> ::= VAR <Identifier> = <Expression> ;
     * every local variable must be initialized
     */
    private Stmt parseDeclStmt() {
        int position = this.currentToken.position;
        // <Identifier>
        this.scan();
        String name = this.parseIdentifier("Illegal local variable name.");

        // "="
        this.checkCurrentTokenMatched("=", "Declaration statement missing the = sign for assignment.");

        // <Expression>
        this.scan();
        Expr expr = this.parseExpression();

        // ";"
        this.checkCurrentTokenMatched(";", "Declaration statement missing a semicolon ;.");

        this.scan();
        return new DeclStmt(position, name, expr);
    }


    /*
     * <ForStmt> ::= FOR ( <Start> ; <Terminate> ; <Increment> ) <STMT>
     * <Start>     ::= EMPTY | <Expression>
     * <Terminate> ::= EMPTY | <Expression>
     * <Increment> ::= EMPTY | <Expression>
     */
    private Stmt parseFor() {
        int position = this.currentToken.position;

        // "("
        this.scan();
        this.checkCurrentTokenMatched("(", "For loop missing the left parenthesis (.");

        // <Start> or ";"
        this.scan();
        Expr initExpr;
        if (this.currentToken.spelling.equals(";")){
            initExpr = null;
        } else {
            initExpr = this.parseExpression();
        }

        // <Terminate> or ";"
        this.scan();
        Expr predExpr;
        if (this.currentToken.spelling.equals(";")){
            predExpr = null;
        } else{
            predExpr = this.parseExpression();
        }

        // <Increment> or ")"
        this.scan();
        Expr updateExpr;
        if (this.currentToken.spelling.equals(")")){
            updateExpr = null;
        } else {
            updateExpr = this.parseExpression();
        }

        // ")"
        this.checkCurrentTokenMatched(")", "For loop missing the right parenthesis ).");

        // <STMT>
        this.scan();
        Stmt bodyStmt = this.parseStatement();

        return new ForStmt(position, initExpr, predExpr, updateExpr, bodyStmt);
    }


    /*
     * <BlockStmt> ::= { <Body> }
     * <Body> ::= EMPTY | <Stmt> <Body>
     */
    private Stmt parseBlock() {
        int position = this.currentToken.position;

        //<Body>
        this.scan();
        StmtList stmtList = new StmtList(position);
        while (!this.currentToken.spelling.equals("}")){
            Stmt stmt = this.parseStatement();
            stmtList.addElement(stmt);
            if (this.currentToken.getKind().equals(EOF)) {
                this.registerError("Block missing the right curly brace }.");
                break;
            }
        }
        this.scan();
        return  new BlockStmt(position, stmtList);
    }

    /*
     * <IfStmt> ::= IF ( <Expr> ) <Stmt> | IF ( <Expr> ) <Stmt> ELSE <Stmt>
     */
    private Stmt parseIf() {
        int position = this.currentToken.position;
        // "("
        this.scan();
        this.checkCurrentTokenMatched("(", "If statement missing left parenthesis (.");

        // <Expr>
        this.scan();
        Expr predExpr = this.parseExpression();

        // ")"
        this.checkCurrentTokenMatched(")", "If statement missing right parenthesis ).");

        // <Stmt>
        this.scan();
        Stmt thenStmt = this.parseStatement();

        // ELSE
        Stmt elseStmt = null;
        if (this.currentToken.kind == ELSE){
            // <Stmt>
            this.scan();
            elseStmt = this.parseStatement();
        }

        return new IfStmt(position, predExpr, thenStmt, elseStmt);
    }

    // ----------------------------------------- Expressions -----------------------------------------
    // Here we introduce the precedence to operations

    /*
     * <Expression> ::= <LogicalOrExpr> <OptionalAssignment>
     * <OptionalAssignment> ::= EMPTY | = <Expression>
     */
    private Expr parseExpression() {
        int position = this.currentToken.position;
        String name = this.currentToken.spelling;

        // <LogicalOrExpr>
        Expr left = this.parseOrExpr();

        // <OptionalAssignment>
        // "="
        while (this.currentToken.spelling.equals("=")){
            this.scan();
            // <LogicalOrExpr>
            Expr right = this.parseOrExpr();
            left = new AssignExpr(position, null, name, right);
        }
        return left;
    }

    /*
     * <LogicalOR> ::= <logicalAND> <LogicalORRest>
     * <LogicalORRest> ::= EMPTY |  || <LogicalAND> <LogicalORRest>
     */
    private Expr parseOrExpr() {
        int position = currentToken.position;

        // <logicalAND>
        Expr left = this.parseAndExpr();

        // "||"
        while (this.currentToken.spelling.equals("||")) {
            this.scan();
            // <logicalAND>
            Expr right = this.parseAndExpr();
            // <LogicalORRest>
            left = new BinaryLogicOrExpr(position, left, right);
        }
        return left;
    }

    /*
     * <LogicalAND> ::= <ComparisonExpr> <LogicalANDRest>
     * <LogicalANDRest> ::= EMPTY |  && <ComparisonExpr> <LogicalANDRest>
     */
    private Expr parseAndExpr() {
        int position = this.currentToken.position;

        // <ComparisonExpr>
        Expr left = this.parseEqualityExpr();

        // "&&"
        while (this.currentToken.spelling.equals("&&")) {
            this.scan();
            // <ComparisonExpr>
            Expr right = this.parseEqualityExpr();
            // <LogicalANDRest>
            left = new BinaryLogicAndExpr(position, left, right);
        }
        return left;
    }

    /*
     * <ComparisonExpr> ::= <RelationalExpr> <equalOrNotEqual> <RelationalExpr> |
     *                     <RelationalExpr>
     * <equalOrNotEqual> ::=  == | !=
     */
    private Expr parseEqualityExpr() {
        int position = this.currentToken.position;

        // <RelationalExpr>
        Expr left = this.parseRelationalExpr();
        Expr right;

        // <equalOrNotEqual>
        // "=="
        if (this.currentToken.spelling.equals("==")){
            this.scan();
            // <RelationalExpr>
            right = this.parseRelationalExpr();
            left = new BinaryCompEqExpr(position, left, right);
        }
        // "!="
        else if (this.currentToken.spelling.equals("!=")){
            this.scan();
            // <RelationalExpr>
            right = this.parseRelationalExpr();
            left = new BinaryCompNeExpr(position, left, right);
        }

        return left;
    }

    /*
     * <RelationalExpr> ::=<AddExpr> | <AddExpr> <ComparisonOp> <AddExpr>
     * <ComparisonOp> ::=  < | > | <= | >= | INSTANCEOF
     */
    private Expr parseRelationalExpr() {
        int position = this.currentToken.position;

        // <AddExpr>
        Expr left = this.parseAddExpr();
        Expr right;

        // <ComparisonOp>
        // "<"
        if (this.currentToken.spelling.equals("<")){
            this.scan();
            // <AddExpr>
            right = this.parseAddExpr();
            left = new BinaryCompLtExpr(position, left, right);
        }
        // ">"
        else if (this.currentToken.spelling.equals(">")){
            this.scan();
            // <AddExpr>
            right = this.parseAddExpr();
            left = new BinaryCompGtExpr(position, left, right);
        }
        // "<="
        else if (this.currentToken.spelling.equals("<=")){
            this.scan();
            // <AddExpr>
            right = this.parseAddExpr();
            left = new BinaryCompLeqExpr(position, left, right);
        }
        // ">="
        else if (this.currentToken.spelling.equals(">=")){
            this.scan();
            // <AddExpr>
            right = this.parseAddExpr();
            left = new BinaryCompGeqExpr(position, left, right);
        }
        // INSTANCEOF
        else if (this.currentToken.kind == INSTANCEOF){
            this.scan();
            // <AddExpr>
            String type = this.parseType();
            left = new InstanceofExpr(position, left, type);
        }

        return left;
    }


    /*
     * <MultiExpr> ::= <NewCastOrUnary> <MoreNCU>
     * <MoreNCU> ::= * <NewCastOrUnary> <MoreNCU> |
     *               / <NewCastOrUnary> <MoreNCU> |
     *               % <NewCastOrUnary> <MoreNCU> |
     *               EMPTY
     */
    private Expr parseMultExpr() {
        int position = this.currentToken.position;

        // <NewCastOrUnary>
        Expr left = this.parseNewCastOrUnary();
        Expr right;

        while (this.currentToken.spelling.equals("*") ||
                this.currentToken.spelling.equals("/") ||
                this.currentToken.spelling.equals("%")) {

            if (this.currentToken.spelling.equals("*")) {
                this.scan();
                // <NewCastOrUnary>
                right = this.parseNewCastOrUnary();
                left = new BinaryArithTimesExpr(position, left, right);
            }
            else if (this.currentToken.spelling.equals("/")){
                this.scan();
                // <NewCastOrUnary>
                right = this.parseNewCastOrUnary();
                left = new BinaryArithDivideExpr(position, left, right);
            }
            else if (this.currentToken.spelling.equals("%")){
                this.scan();
                // <NewCastOrUnary>
                right = this.parseNewCastOrUnary();
                left = new BinaryArithModulusExpr(position, left, right);
            }
        }
        return left;
    }

    /*
     * <AddExpr>::Ôºù <MultExpr> <MoreMultExpr>
     * <MoreMultExpr> ::= EMPTY | + <MultExpr> <MoreMultExpr> | - <MultExpr> <MoreMultExpr>
     */
    private Expr parseAddExpr() {
        int position = this.currentToken.position;

        // <MultExpr>
        Expr left = this.parseMultExpr();
        Expr right;

        // <MoreMultExpr>
        while (this.currentToken.spelling.equals("+") || this.currentToken.spelling.equals("-") ) {

            // + <MultExpr> <MoreMultExpr>
            if (this.currentToken.spelling.equals("+")) {
                this.scan();
                // <MultExpr>
                right = parseMultExpr();
                left = new BinaryArithPlusExpr(position, left, right);
            }
            // - <MultExpr> <MoreMultExpr>
            else if (this.currentToken.spelling.equals("-")){
                this.scan();
                // <MultExpr>
                right = parseMultExpr();
                left = new BinaryArithMinusExpr(position, left, right);
            }
        }
        return left;
    }

    /*
     * <NewCastOrUnary> ::= < NewExpression> | <CastExpression> | <UnaryPrefix>
     */
    private Expr parseNewCastOrUnary() {
        Expr expr;

        switch (this.currentToken.kind) {
            case NEW:
                expr = this.parseNew();
                break;
            case CAST:
                expr = this.parseCast();
                break;
            default:
                expr = this.parseUnaryPrefix();
                break;
        }
        return expr;
    }


    /*
     * <NewExpression> ::= NEW <Identifier> ( ) | NEW <Identifier> [ <Expression> ]
     */
    private Expr parseNew() {
        int position = this.currentToken.position;

        // <identifier>
        this.scan();
        String type = this.parseIdentifier("Illegal new object/array name.");

        // if creating a new array [<Expression>]
        if (this.currentToken.spelling.equals("[")){
            this.scan();
            // <Expression>
            Expr exp = this.parseExpression();
            // "]"
            this.checkCurrentTokenMatched("]", "New statement for an array missing a right bracket ].");
            this.scan();

            return new NewArrayExpr(position, type, exp);
        }
        // if creating a new object ()
        else if (this.currentToken.spelling.equals("(")) {
            // )
            this.scan();
            this.checkCurrentTokenMatched(")", "New statement for an object missing a right parenthesis ).");
            this.scan();

            return new NewExpr(position, type);
        }
        // illegal new statement
        else {
            this.registerError("Illegal new statement for objects or arrays.");
            return null;
        }

    }

    /*
     * <CastExpression> ::= CAST ( <Type> , <Expression> )
     */
    private Expr parseCast() {
        int position = this.currentToken.position;

        // "("
        this.scan();
        this.checkCurrentTokenMatched("(", "Cast expression missing a left parenthesis (.");

        // <Type>
        this.scan();
        String type = this.parseType();

        // ","
        this.checkCurrentTokenMatched(",", "Cast expression has illegal arguments.");

        // <Expression>
        this.scan();
        Expr expr = this.parseExpression();

        // ")"
        this.checkCurrentTokenMatched(")", "Cast expression missing a right parenthesis ).");
        this.scan();

        return new CastExpr(position, type, expr);
    }

    /**
     * Checks whether the current token is a PrefixOp.
     *
     * @return true if the current token is one of the PrefixOp.
     *         false if the current token is not one of the PrefixOp
     */
    private boolean isPrefixOp() {
        return this.currentToken.spelling.equals("-") || this.currentToken.spelling.equals("!")
                || this.currentToken.spelling.equals("++") || this.currentToken.spelling.equals("--");
    }

    /*
     * <UnaryPrefix> ::= <PrefixOp> <UnaryPrefix> | <UnaryPostfix>
     * <PrefixOp> ::= - | ! | ++ | --
     */
    private Expr parseUnaryPrefix() {
        Expr expr = null;

        // if this.currentToken is <PrefixOp>
        if (this.isPrefixOp()) {
            while (this.isPrefixOp()) {
                if (this.currentToken.spelling.equals("-")) {
                    this.scan();
                    expr = new UnaryNegExpr(this.currentToken.position, this.parseUnaryPrefix());
                } else if (this.currentToken.spelling.equals("!")) {
                    this.scan();
                    expr = new UnaryNotExpr(this.currentToken.position, this.parseUnaryPrefix());
                } else if (this.currentToken.spelling.equals("++")) {
                    this.scan();
                    expr = new UnaryIncrExpr(this.currentToken.position, this.parseUnaryPrefix(), false);
                } else if (this.currentToken.spelling.equals("--")) {
                    this.scan();
                    expr = new UnaryDecrExpr(this.currentToken.position, this.parseUnaryPrefix(), false);
                }
            }
        }
        else {
            // <UnaryPostfix>
            expr = this.parseUnaryPostfix();
        }
        return expr;
    }

    /*
     * <UnaryPostfix> ::= <Primary> <PostfixOp>
     * <PostfixOp> ::= ++ | -- | EMPTY
     */
    private Expr parseUnaryPostfix() {
        int position = this.currentToken.position;

        // <Primary>
        Expr expr = this.parsePrimary();

        // <PostfixOp>
        if (this.currentToken.spelling.equals("++")){
            this.scan();
            return new UnaryIncrExpr(position, expr, true);
        }
        else if (this.currentToken.spelling.equals("--")){
            this.scan();
            return new UnaryDecrExpr(position, expr, true);
        }
        else{
            return expr;
        }
    }
    
    /*
     * <Primary> ::= ( <Expression> ) | <IntegerConst> | <BooleanConst> | <StringConst> | <VarExpr> | <DispatchExpr>
     * <VarExpr> ::= <VarExprPrefix> <Identifier> <VarExprSuffix>
     * <VarExprPrefix> ::= SUPER . | THIS . | EMPTY
     * <VarExprSuffix> ::= [ <Expr> ] | EMPTY
     * <DispatchExpr> ::= <DispatchExprPrefix> <Identifier> ( <Arguments> )
     * <DispatchExprPrefix> ::= <Primary> . | EMPTY
     */
    private Expr parsePrimary() {
        int position = currentToken.position;
        Expr expr;
        Expr ref = null;
        ExprList paraList;

        if ( currentToken.kind == Token.Kind.LPAREN){
            currentToken = scanner.scan();
            expr = parseExpression();
            if (currentToken.kind != Token.Kind.RPAREN) {
                this.registerError("Unclosed parenthesis");
            }
        }
        // <IntegerConst>
        if (currentToken.kind ==  INTCONST) {
            expr = this.parseIntConst();
        }
        // <BooleanConst>
        else if (currentToken.kind == STRCONST) {
            expr = this.parseStringConst();
        }
        // <StringConst>
        else if (currentToken.kind == BOOLEAN) {
            expr = this.parseBoolean();
        }
        else {
            if (currentToken.spelling.equals("this") || currentToken.spelling.equals("super")) {
                expr = new VarExpr(position, null, currentToken.spelling);
                this.scan();
                if (!this.currentToken.spelling.equals(".")) {
                    return expr;
                }
                this.scan();
                ref = expr;
            }

            String name = this.parseIdentifier("Non-identifier " + this.currentToken.spelling + " was found where identifier expected."); // parse name (variable or method)

            if (!currentToken.spelling.equals("(")) {
                if (!currentToken.spelling.equals("[")) {//not array member. like this.a
                    expr = new VarExpr(position, ref, name);
                }

                else { //array member like this.a[2]
                    this.scan();
                    Expr index = parseExpression();
                    expr = new ArrayExpr(position, ref, name, index);
                    this.checkCurrentTokenMatched("]", "Non-primary found where primary expected");
                    this.scan();
                }
            } else {//dispatch like this.method() or method()
                this.scan();
                paraList = this.parseArguments();
                expr = new DispatchExpr(position, ref, name, paraList);
            }
            if(this.currentToken.spelling.equals(".")){
                this.scan();

                if(this.currentToken.spelling.equals("length")){
                    expr = new VarExpr(position, ref, "length" );
                    if (this.currentToken.spelling.equals(".")||this.currentToken.spelling.equals("(")) {
                        this.registerError("Cannot call method on length");
                    }
                    this.scan();
                    return expr;
                }
                expr = parseMethodCall(ref, position);
            }
            while(this.currentToken.spelling.equals(".")){
                this.scan();
                expr = parseMethodCall(expr, position);
            }
        }
        return expr;
    }

    /**
     * Helper method to parse method.
     *
     * @param ref reference expression
     * @param position the position of the expression node
     * @return the expression node
     */
    private DispatchExpr parseMethodCall(Expr ref, int position) {
        String name = parseIdentifier("Non-identifier " + this.currentToken.spelling + " was found where identifier expected.");
        this.checkCurrentTokenMatched("(", "Non-primary found where primary expected.");
        this.scan();
        ExprList paraList = this.parseArguments();
        DispatchExpr expr = new DispatchExpr(position, ref, name, paraList);
        return expr;
    }

    /*
     * <Arguments> ::= EMPTY | <Expression> <MoreArgs>
     * <MoreArgs>  ::= EMPTY | , <Expression> <MoreArgs>
     */
    private ExprList parseArguments(){
        int position = this.currentToken.position;
        ExprList args = new ExprList(position);

        // checks for the empty arguments case
        if ( this.currentToken.spelling.equals(")") ) {
            this.scan();
            return args;
        }

        //if not empty, parse the first argument
        Expr arg = this.parseExpression();
        args.addElement(arg);

        //continue parsing arguments
        while (this.currentToken.spelling.equals(",")) {
            this.scan();
            arg = this.parseExpression();
            args.addElement(arg);
        }

        this.scan();
        return args;
    }

    /*
     * <Parameters>  ::= EMPTY | <Formal> <MoreFormals>
     * <MoreFormals> ::= EMPTY | , <Formal> <MoreFormals>
     */
    private FormalList parseParameters() {
        int position = this.currentToken.position;
        FormalList params = new FormalList(position);

        // checks for the empty parameters case
        if ( this.currentToken.spelling.equals(")") ) {
            return params;
        }

        // if not empty, parse the first parameter
        // and add it to the formal list
        Formal param = this.parseFormal();
        params.addElement(param);

        // continue parsing parameters and adding them to the list
        while (this.currentToken.spelling.equals(",")) {
            this.scan();
            param = this.parseFormal();
            params.addElement(param);
        }
        return params;
    }

    /*
     * <Formal> ::= <Type> <Identifier>
     */
    private Formal parseFormal() {
        return (new Formal(this.currentToken.position, this.parseType(),
                this.parseIdentifier("Illegal formal name.")));
    }

    /*
     * <Type> ::= <Identifier> <Brackets>
     * <Brackets> ::= EMPTY | [ ]
     */
    private String parseType() {
        // <Identifier>
        String type = this.parseIdentifier("Illegal type name.");
        // <Brackets>
        if (this.currentToken.getSpelling() == "[") {
            this.scan();
            if(this.currentToken.getSpelling() == "]") {
                this.scan();
                return (type + "[]");
            } else {
                this.registerError("Open bracket found without closing bracket for an array type.");
            }
        }
        return type;
    }

    // ---------------------------------------- Terminals ----------------------------------------
    /**
     * Parses the identifier terminal.
     * Throws an error if the current Token is not an identifier.
     *
     * @return the spelling of the terminal
     */
    private String parseIdentifier(String errorMsg) {
        if (this.currentToken.kind != IDENTIFIER) {
            this.registerError(errorMsg);
        }
        Token tmpToken = this.currentToken;
        this.scan();
        return tmpToken.spelling;
    }

    /**
     * Parses the String Constant terminal.
     *
     * @return a ConstStringExpr object.
     */
    private ConstStringExpr parseStringConst() {
        Token tmpToken = this.currentToken;
        this.scan();
        return new ConstStringExpr(tmpToken.position, tmpToken.spelling);
    }

    /**
     * Parses the Integer Constant terminal.
     *
     * @return a ConstIntExpr object.
     */
    private ConstIntExpr parseIntConst() {
        Token tmpToken = this.currentToken;
        this.scan();
        return new ConstIntExpr(tmpToken.position, tmpToken.spelling);
    }

    /**
     * Parses the Boolean Constant terminal.
     *
     * @return a ConstBooleanExpr object.
     */
    private ConstBooleanExpr parseBoolean() {
        Token tmpToken = this.currentToken;
        this.scan();
        return new ConstBooleanExpr(tmpToken.position, tmpToken.spelling);
    }

    /**
     * Main test method
     * @param args
     */
    public static void main(String[] args) {
        // command line arguments we used for testing purpose
        for (int i=0; i < args.length; i++) {
            String filename = args[i];
            System.out.println("\n------------------ " + filename + " ------------------" + "\n");

            ErrorHandler handler = new ErrorHandler();
            Parser parser = new Parser(handler);

            try{
                Program program = parser.parse(filename);
                Drawer drawer = new Drawer();
                drawer.draw(filename, program);
                System.out.println("Parsing was successful!");
            } catch (CompilationException e) {
                List<Error> errorList = handler.getErrorList();
                for (Error err : errorList) {
                    System.out.println(err.toString());
                }
                if (errorList.size() == 1) {
                    System.out.println("\n1 error was found.");
                } else {
                    System.out.println("\n" + errorList.size() + " errors were found.");
                }
            } catch (Exception e) {
                System.out.println(e);
                System.out.println("ERROR: Parsing " + filename + " failed!");
            }
        }
    }
}